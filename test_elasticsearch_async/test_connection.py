import asyncio
import json
import logging

import aiohttp

from pytest import mark, raises

from elasticsearch import NotFoundError, ConnectionTimeout
from elasticsearch.connection.http_urllib3 import create_ssl_context

from elasticsearch_async.connection import AIOHttpConnection


@mark.asyncio
async def test_info(connection):
    status, headers, data = await connection.perform_request('GET', '/')

    data = json.loads(data)

    assert status == 200
    assert  {'body': '', 'method': 'GET', 'params': {}, 'path': '/'} == data

def test_auth_is_set_correctly(event_loop):
    connection = AIOHttpConnection(http_auth=('user', 'secret'), loop=event_loop)
    assert connection.session._default_auth == aiohttp.BasicAuth('user', 'secret')

    connection = AIOHttpConnection(http_auth='user:secret', loop=event_loop)
    assert connection.session._default_auth == aiohttp.BasicAuth('user', 'secret')

def test_ssl_context_is_correctly(event_loop):
    context = create_ssl_context(cafile="test_elasticsearch_async/ca.crt")
    connection = AIOHttpConnection(ssl_context=context, http_auth=('user', 'secret'), loop=event_loop)
    assert connection.session.connector._ssl.get_ca_certs() == [{
        'subject': ((('commonName', 'Elastic Certificate Tool Autogenerated CA'),),),
        'issuer': ((('commonName', 'Elastic Certificate Tool Autogenerated CA'),),),
        'version': 3,
        'serialNumber': 'C732AB792FAC34EB252EE2F03A316CD8CFE203B3',
        'notBefore': 'Aug 26 18:27:28 2017 GMT',
        'notAfter': 'Aug 25 18:27:28 2020 GMT'
    }]


@mark.asyncio
async def test_request_is_properly_logged(connection, caplog, port, server):
    server.register_response('/_cat/indices', {'cat': 'indices'})
    await connection.perform_request('GET', '/_cat/indices', body=b'{}', params={"format": "json"})

    for logger, level, message in caplog.record_tuples:
        if logger == 'elasticsearch' and level == logging.INFO:
            assert message.startswith('GET http://localhost:%s/_cat/indices?format=json [status:200 request:' % port)
            break
    else:
        assert False, 'Message not found'

    assert ('elasticsearch', logging.DEBUG, '> {}') in caplog.record_tuples
    assert ('elasticsearch', logging.DEBUG, '< {"cat": "indices"}') in caplog.record_tuples

@mark.asyncio
async def test_error_is_properly_logged(connection, caplog, port, server):
    server.register_response('/i', status=404)
    with raises(NotFoundError):
        await connection.perform_request('GET', '/i', params={'some': 'data'})

    for logger, level, message in caplog.record_tuples:
        if logger == 'elasticsearch' and level == logging.WARNING:
            assert message.startswith('GET http://localhost:%s/i?some=data [status:404 request:' % port)
            break
    else:
        assert False, "Log not received"

@mark.asyncio
async def test_timeout_is_properly_raised(connection, server):
    async def slow_request():
        await asyncio.sleep(0.01)
        return {}
    server.register_response('/_search', slow_request())

    with raises(ConnectionTimeout):
        await connection.perform_request('GET', '/_search', timeout=0.0001)


def test_dns_cache_is_enabled_by_default(event_loop):
    connection = AIOHttpConnection(loop=event_loop)
    assert connection.session.connector.use_dns_cache is True


def test_dns_cache_can_be_disabled(event_loop):
    connection = AIOHttpConnection(loop=event_loop, use_dns_cache=False)
    assert connection.session.connector.use_dns_cache is False
